# `<centre> Проект 1: Анализ резюме из HeadHunter`

1. Исследование структуры данных
2. Преобразование данных
3. Исследование зависимостей в данных
4. Очистка данных

Для проекта использован датасет, содержащий информацию о резюме соискателей с сайта [HeadHunter]()(https://hh.ru/?hhtmFrom=main&customDomain=1 "сайт Headhunter")

Датасет можно посмотреть [здесь](https://drive.google.com/file/d/1VO9Q7wyVHH8qelDE1hk2lRdCJKW56Nuv/view?usp=share_linkhttps://drive.google.com/file/d/1VO9Q7wyVHH8qelDE1hk2lRdCJKW56Nuv/view?usp=share_link)

## `<centre> 1. `Исследование структуры данных

Таблица состоит из 44744 строк и 12 столбцов:

* Пол, возраст
* ЗП
* Ищет работу на должность
* Город, переезд, командировки
* Занятость
* График
* Опыт работы
* Последнее/нынешнее место работы
* Последняя/нынешняя должность
* Образование и ВУЗ
* Обновление резюме
* Автo

## `<center> 2. Преобразование данных`

Начнем с признака **"Образование и ВУЗ"**. Его текущий формат это: **<УровеньобразованиягодвыпускаВУЗспециальность...>**. Например:

* Высшее образование 2016 Московский авиационный институт (национальный исследовательский университет)...
* Неоконченное высшее образование 2000  Балтийская государственная академия рыбопромыслового флота…

Нас будет интересовать только уровень образования.

Создадим с помощью функции-преобразования новый признак **"Образование"**, который будет иметь 4 категории: "высшее", "неоконченное высшее", "среднее специальное" и "среднее".

```python
# Создадим функцию 'get_level_education' для преобразования столбца "Образование и ВУЗ"
def get_level_education(education):
    # Создадим список возможных видов образования
    level_education = [
                     'Высшее',
                     'Неоконченное высшее',
                     'Среднее специальное',
                     'Среднее'
                     ]
    # Разобъем строку с помошью метода split() для получения  словаря со значениями
    education_split = education.split(' ')
    # Обрезаем список, оставляя в нём только первые два элемента,
    # потенциальный уровень образования, и заносим в переменную education_type.
    education_type = education_split[:2]
    # Так как есть неоконченое образование, то 
    # необходимо объеденить первые два слова для проверки условия
    education_type_join = ' '.join(education_type[:2])
    # Делаем проверку на то, что полученный уровень образования, является допустимым.
    # Для этого проверяем его на наличие в списке level_education.
    if education_type_join in level_education:
        return education_type_join.lower()
    else:
        education_type = education_split[:1]
    return education_type[0].lower()

# Применяем написанную функцию для создания нового признака  
headhunter_df['Образование'] = headhunter_df['Образование и ВУЗ'].apply(get_level_education)
#Проверяем, получившиеся значения в признаке 'Образование'
headhunter_df['Образование'].unique()
```

Теперь нас интересует столбец **"Пол, возраст"**. Сейчас он представлен в формате **<Пол,возраст,датарождения>**. Например:

* Мужчина , 39 лет , родился 27 ноября 1979
* Женщина , 21 год , родилась 13 января 2000

Нам необходимо выделить каждый параметр в отдельный столбец.

Создадим два новых признака **"Пол"** и **"Возраст"**. При этом важно учесть:

* Признак пола должен иметь 2 уникальных строковых значения: 'М' - мужчина, 'Ж' - женщина.
* Признак возраста должен быть представлен целыми числами.

  ```python
  # Создадим функцию 'get_gender', которая выделяет пол соискателя
  # и возвращает его как "М" и "Ж"
  def get_gender(gender):
  # Разобьем строку с помощью метода split() и выделим первое слово (индекс[0])
      gender_list = gender.split()[0]
  # С попомщью условия преобразуем 'Мужчина' и 'Женщина' в 'М' и 'Ж'
      if gender_list == 'Мужчина': return 'М'
      elif gender_list == 'Женщина': return 'Ж'

  # Создадим функцию 'get_age', которая выделяет возраст соискателя
  def get_age(age):
  # Разбиваем строку и берем элемент под индексом 2
      age_list = age.split()[2]
      return age_list  

  # Создадим признак 'Пол'   
  headhunter_df['Пол'] = headhunter_df['Пол, возраст'].apply(get_gender)
  # Создадим признак возраст
  headhunter_df['Возраст'] = headhunter_df['Пол, возраст'].apply(get_age)

  # Удалим признак 'Пол, возраст'
  headhunter_df = headhunter_df.drop('Пол, возраст', axis=1)
  ```

Следующим этапом преобразуем признак **"Опыт работы"**. Его текущий формат - это: **[Опытработы:nлетmмесяцев,периодыработывразличныхкомпаниях…](%D0%9E%D0%BF%D1%8B%D1%82%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B:n%D0%BB%D0%B5%D1%82m%D0%BC%D0%B5%D1%81%D1%8F%D1%86%D0%B5%D0%B2,%D0%BF%D0%B5%D1%80%D0%B8%D0%BE%D0%B4%D1%8B%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B%D0%B2%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D1%85%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BD%D0%B8%D1%8F%D1%85%E2%80%A6)**.

Из столбца нам необходимо выделить общий опыт работы соискателя в месяцах, новый признак назовем "Опыт работы (месяц)"

```python
# Создадим функцию get_work_experience, которая
# преобразует опыт работы из указанных значений в месяцы
def get_work_experience(arg):
# Если значение отсутствует или 'Не указано',
# функция возвращает None
    if arg is np.nan or arg == 'Не указано':
        return None
# Создаем списки с вариантами обозначения года и месяца
    year_words=['год', 'года', 'лет']
    month_words=['месяц', 'месяца', 'месяцев']
# Разбиваем строку методом split(), берем первые 6 элементов
    arg_splitted = arg.split(' ')[:7]
    years = 0
    months = 0
# Проходим циклом по строкам
    for index, item in enumerate (arg_splitted):
        if item in year_words:
            years = int(arg_splitted[index-1])
        if item in month_words:
            months = int(arg_splitted[index-1])
    return int(years*12 + months)

# Создаем признак 'Опыт работы (месяц)'
headhunter_df['Опыт работы (месяц)'] = headhunter_df['Опыт работы'].apply(get_work_experience)
# Удаляем признак 'Опыт работы'
headhunter_df = headhunter_df.drop('Опыт работы', axis=1)

```

Следующий на очереди признак "Город, переезд, командировки". Информация в нем представлена в следующем виде: **<Город,(метро),готовностькпереезду(городадляпереезда),готовностьккомандировкам>**. В скобках указаны необязательные параметры строки. Например, можно встретить следующие варианты:

* Москва , не готов к переезду , готов к командировкам
* Москва , м. Беломорская , не готов к переезду, не готов к командировкам
* Воронеж , готов к переезду (Сочи, Москва, Санкт-Петербург) , готов к командировкам

Создадим отдельные признаки **"Город"**, **"Готовность к переезду"**, **"Готовность к командировкам"**. При этом важно учесть:

* Признак **"Город"** должен содержать только 4 категории: "Москва", "Санкт-Петербург" и "город-миллионник" (их список ниже), остальные обозначьте как "другие".
* Список городов-миллионников:

  `<code>`million_cities = ['Новосибирск', 'Екатеринбург','Нижний Новгород','Казань', 'Челябинск','Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж','Волгоград']

  </code>

  Инфорация о метро, рядом с которым проживает соискатель нас не интересует.

Признак **"Готовность к переезду"** должен иметь два возможных варианта: True или False. Обратите внимание, что возможны несколько вариантов описания готовности к переезду в признаке "Город, переезд, командировки". Например:

* * … , готов к переезду , …
  * … , не готова к переезду , …
  * … , готова к переезду (Москва, Санкт-Петербург, Ростов-на-Дону)
  * … , хочу переехать (США) , …

  Нас интересует только сам факт возможности или желания переезда.
* Признак **"Готовность к командировкам"** должен иметь два возможных варианта: True или False. Обратите внимание, что возможны несколько вариантов описания готовности к командировкам в признаке "Город, переезд, командировки". Например:

  … , готов к командировкам , …
* * … , готова к редким командировкам , …
  * … , не готов к командировкам , …

  Нас интересует только сам факт готовности к командировке.

  Еще один важный факт: при выгрузки данных у некоторых соискателей "потерялась" информация о готовности к командировкам. Давайте по умолчанию будем считать, что такие соискатели не готовы к командировкам.

  ```python
  # Создаем функцию get_city, которая преобразует город соискателя в 4 новые категории:
  # Москва, Санкт-Петербург, город-милионник и другие
  def get_city (city):
  # В переменной million_cities создадим список городов-миллионников
      million_cities = [
          'Новосибирск',
          'Екатеринбург',
          'Нижний Новгород',
          'Казань',
          'Челябинск',
          'Омск',
          'Самара',
          'Ростов-на-Дону',
          'Уфа',
          'Красноярск',
          'Пермь',
          'Воронеж',
          'Волгоград'
          ]
  # Разделим строку и возьмем оттуда элемент с 0 индексом
      candidate_city = city.split()[0]
  # Проверим город соискателя в списке городов-милионников
      if candidate_city in million_cities:
          return 'город-миллионник'
  # Проверим город соискателя на соответстиве Москве и Санкт-Петербургу
      elif candidate_city == 'Москва': return 'Москва'
      elif candidate_city == 'Санкт-Петербург': return 'Санкт-Петербург'
  # Если ни одно из условий не выполняется, преобразуем город соискателя в 'другие'
      else:
          return 'другие'

  # Создадим функцию get_relocation, которая определяет готовность соискателя к переезду  
  def get_relocation(relocation):
      return False if 'не готов к переезду' in relocation or 'не готова к переезду' in relocation else True

  # Создадим функцию get_business_trip, которая определяет готовность соискателя к командировкам
  def get_business_trip(trip):
      return False if 'не готов к командировкам' in trip or 'не готова к командировкам' in trip else True

  # Создадим признак 'Город'
  headhunter_df['Город'] = headhunter_df['Город, переезд, командировки'].apply(get_city)   
  # Создадим признак 'Готовность к переезду'
  headhunter_df['Готовность к переезду'] = headhunter_df['Город, переезд, командировки'].apply(get_relocation)
  # Создадим признак 'Готовность к командировкам'
  headhunter_df['Готовность к командировкам'] = headhunter_df['Город, переезд, командировки'].apply(get_business_trip)

  # Удалим признак 'Город, переезд, командировки'
  headhunter_df = headhunter_df.drop('Город, переезд, командировки', axis=1)
  ```

Рассмотрим поближе признаки **"Занятость"** и **"График"**. Сейчас признаки представляют собой набор категорий желаемой занятости (полная занятость, частичная занятость, проектная работа, волонтерство, стажировка) и желаемого графика работы (полный день, сменный график, гибкий график, удаленная работа, вахтовый метод).

На сайте hh.ru соискатель может указывать различные комбинации данных категорий, например:

* полная занятость, частичная занятость
* частичная занятость, проектная работа, волонтерство
* полный день, удаленная работа
* вахтовый метод, гибкий график, удаленная работа, полная занятость

Такой вариант признаков имеет множество различных комбинаций, а значит множество уникальных значений, что мешает анализу.

Cоздадим признаки-мигалки для каждой категории: если категория присутствует в списке желаемых соискателем, то в столбце на месте строки рассматриваемого соискателя ставится True, иначе - False.

```python
# Создадим список с видми занятости
employments = ['полная занятость', 'частичная занятость',
               'проектная работа', 'волонтерство', 'стажировка']
# Создадим список с видами рабочего графика
charts = ['полный день', 'сменный график', 
         'гибкий график', 'удаленная работа',
         'вахтовый метод']
# В цикле распакуем значения вида занятости и графика из объединенного списка
# и создадим соответствующие признаки
for employment, chart in zip(employments, charts):
    headhunter_df[employment] = headhunter_df['Занятость'].apply(lambda x: employment in x)
    headhunter_df[chart] = headhunter_df['График'].apply(lambda x: chart in x)
  
# Удалим признаки 'Занятость' и 'График'
headhunter_df = headhunter_df.drop(['Занятость', 'График'], axis=1)
```

Наконец, мы добрались до самого главного и самого важного - признака заработной платы **"ЗП"**.

В чем наша беда? В том, что помимо желаемой заработной платы соискатель указывает валюту, в которой он бы хотел ее получать, например:

* 30000 руб.
* 50000 грн.
* 550 USD

Нам бы хотелось видеть заработную плату в единой валюте, например, в рублях.

Информацию об изменении курса валют возьмем с сайта MDF.RU

Подготовленный датасет находится [здесь](https://drive.google.com/file/d/1OfDyCDACufJzOgfW0vLH97JdAsZzFOW-/view?usp=share_link)

Создадим новый DataFrame из полученного файла. В таблице нас будут интересовать столбцы:

* "currency" - наименование валюты в ISO кодировке,
* "date" - дата,
* "proportion" - пропорция,
* "close" - цена закрытия (последний зафиксированный курс валюты на указанный день).

  Дату по которй определяется курс возьмем из признака **"Обновление резюме"**, в нем содержится дата и время, когда соискатель выложил текущий вариант своего резюме. Нас интересует только дата, по ней бы и будем сопоставлять курсы валют.

Теперь у нас есть вся необходимая информация для того, чтобы создать признак "ЗП (руб)" - заработная плата в рублях.

```python
 Создадим функцию get_salary_num, которая выделяет желаемую з/п 
def get_salary_num(arg):
    salary = float(arg.split(' ')[0])
    return salary

# Создадим функцию get_salary_currency, которая преобразует название валют ISO-кодировку
def get_salary_currency(arg):
# Разделим строку, уберем точки с помощью метода replace()
    currency = arg.split(' ')[1].replace('.', '')
# Создадим список валют, которые уже указаны в ISO-кодировке
    currency_constant_list = ['USD', 'KZT', 'USD', 'EUR', 'KGS', 'AZN']
# Если валюта в списке, возвращаем без изменений
    if currency in currency_constant_list: return currency  
# Если используется другое название, заменяем на соответствующее ISO-кодировке значение  
    elif currency == 'белруб': return 'BYN'
    elif currency == 'грн': return 'UAH'
    elif currency == 'сум': return 'UZS'
# Если ни одно из условий не выполнено возвращаем 'RUB'
    else:
        return 'RUB'
  
# Создаем временные признаки 'ЗП (tmp)' и 'Курс (tmp)'  
headhunter_df['ЗП (tmp)'] = headhunter_df['ЗП'].apply(get_salary_num)
headhunter_df['Курс (tmp)'] = headhunter_df['ЗП'].apply(get_salary_currency)  

# Преобразуем признаки даты в обоих DataFrame в тип datetime
# и выделяем из них дату  
rates_df['date'] = pd.to_datetime(rates_df['date'], dayfirst=True).dt.date
headhunter_df['Обновление резюме'] = pd.to_datetime(headhunter_df['Обновление резюме'], dayfirst=True).dt.date   

# С помощью метода merge() создаем объединенный DataFrame merged
merged = headhunter_df.merge(
    rates_df, 
    left_on=['Курс (tmp)', 'Обновление резюме'],
    right_on=['currency', 'date',], 
    how='left'
)

# В признаках 'close' и 'proportion' заполняем пустые значения единицами
merged['close'] = merged['close'].fillna(1)
merged['proportion'] = merged['proportion'].fillna(1)

# В headhunter_df создаем новый признак зарплаты в рублях 'ЗП (руб)'
headhunter_df['ЗП (руб)'] = merged['close'] * merged['ЗП (tmp)'] / merged['proportion']

# Удаляем ненужные признаки из headhunter_df
headhunter_df = headhunter_df.drop(['ЗП', 'ЗП (tmp)', 'Курс (tmp)'], axis=1)
```

## `<center> 3. Исследование зависимостей в данных`

* Распределение признака Возраст
* Распределение признака Опыт работы

* Распределение признака желаемой заработной платы
* Зависимость медианной желаемой заработной платы от уровня образования

* Распределение желаемой заработной платы в зависимости от города
* Зависимость медианной заработной платы от готовности к переезду и командировкам

* Зависимость медианной заработной платы от возраста и уровня образования
* Зависимость желаемой медианной заработной платы относительно пола и возраста

* Распределение ожидаемой заработной платы в зависимости от должности

## `<center> Очистка данных`

* Поиск и удаление дубликатов
* Удаление пропусков и замена константами
* Поиск выбросов методом "z-отклонений"
